## 1228. [S/W 문제해결 기본] 8일차 - 암호문1

<br>

## 문제

0 ~ 999999 사이의 수를 나열하여 만든 암호문이 있다.

암호문을 급히 수정해야 할 일이 발생했는데, 이 암호문은 특수 제작된 처리기로만 수정이 가능하다.

이 처리기는 다음과 같이 1개의 기능을 제공한다.

<br>

\1. **I(삽입) x, y, s** : 앞에서부터 x의 위치 바로 다음에 y개의 숫자를 삽입한다. s는 덧붙일 숫자들이다.[ ex) **I 3 2 123152 487651** ]

위의 규칙에 맞게 작성된 명령어를 나열하여 만든 문자열이 주어졌을 때, 암호문을 수정하고, 수정된 결과의 처음 10개 숫자를 출력하는 프로그램을 작성하여라.

<br>

**[입력]**

첫 번째 줄 : 원본 암호문의 길이 N ( 10 ≤ N ≤ 20 의 정수)

두 번째 줄 : 원본 암호문

세 번째 줄 : 명령어의 개수 ( 5 ≤ N ≤ 10 의 정수)

네 번째 줄 : 명령어

위와 같은 네 줄이 한 개의 테스트 케이스이며, 총 10개의 테스트 케이스가 주어진다.

<br>

**[출력]**

\# 기호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 수정된 암호문의 처음 10개 항을 출력한다.

## 입력

``` python
# 1
11
449047 855428 425117 532416 358612 929816 313459 311433 472478 589139 568205
7
I 1 5 400905 139831 966064 336948 119288 I 8 6 436704 702451 762737 557561 810021 771706 I 3 8 389953 706628 552108 238749 661021 498160 493414 377808 I 13 4 237017 301569 243869 252994 I 3 4 408347 618608 822798 370982 I 8 2 424216 356268 I 4 10 512816 992679 693002 835918 768525 949227 628969 521945 839380 479976

# 2
19
566753 244528 233616 328235 268163 292641 646305 944392 643695 385788 444752 939244 637877 325283 779273 712343 953523 846222 204307
5
I 0 4 600576 565945 486128 594841 I 0 1 150706 I 8 8 556294 697547 932203 845517 116062 300371 621038 358830 I 10 8 747039 701738 805438 502654 476665 919177 367272 859931 I 15 3 844423 973297 658751
```

<br>

## 출력

``` python
#1 449047 400905 139831 408347 512816 992679 693002 835918 768525 949227
#2 150706 600576 565945 486128 594841 566753 244528 233616 556294 697547
...
```

<br>

## 📝 풀어보기



``` python
# 제한 시간 내 풀지 못한 문제, 07.30 00:50 수정
# I(삽입) x, y, s : 앞에서부터 x의 위치 바로 다음에 y개의 숫자를 삽입한다.
# s는 덧붙일 숫자들이다.[ ex I 3 2 123152 487651 ]
for i in range(10):
    st = int(input()) # 원본 암호문 길이
    nd = list(map(int, input().split())) # 원본 암호문 
    rd = int(input()) # 명령어의 개수
    th = list(input().split()) # 삽입할 암호문의 값

    for j in range(len(th)): # 삽입할 암호문 리스트의 길이만큼
        if th[j] == "I": # I가 발견되면
            index = int(th[j+1]) # index에 x의 위치 1, 8, 3, 13, 3, 8, 4
            number = int(th[j+2]) # number에 y개의 숫자 5, 6, 8, 4, 4, 2, 10
            for h in range(number): # number의 y개 숫자 순회 01234, 012345, 01234567...
                # 원본 암호문의 x의 위치에서(index) 차례대로(+h) 
                # 삽입할 암호문(th)의 값을 넣어준다.(th[j+2+(h+1)]) 
                # j = 0 h = 0, th[3] = 400905 j = 0 h = 1, th[4] = 139831..
                # j = 8 h = 0, th[8] = 436704 j = 8 h = 1, th[9] = 702451..
                nd.insert(index+h,int(th[j+2+(h+1)])) 
                # print("index+h :"+str(index+h))
                # print("j+2+(h+1)"+str(j+2+(h+1)))
        else:
            continue
        # 테스트 케이스 번호 출력과 join으로 한 칸씩 띄워주면서 int 리스트인 nd를 형변환 한 후 10개 잘라 출력
    print("#{} {}".format(i+1, ' '.join(map(str, nd[0:10]))))

    
# 방법2
T = 10

for t in range(1, T+1):
    origin_len = int(input())
    origin_list = map(int, input().split())

    command_len = int(input())
    command_list = input().split()
    # i의 초기화
    i = 0

    while i < len(command_list):
        command = command_list[i]
        if command == "I":
            x = command_list[i+1]
            y = command_list[i+2]
            number_list = command_list[i+3:i+3+y]

    for number in number_list[::-1]:
        origin_list.insert(x, int(number))
```

